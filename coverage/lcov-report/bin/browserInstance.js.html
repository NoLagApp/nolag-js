
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for bin/browserInstance.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../prettify.css" />
    <link rel="stylesheet" href="../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../index.html">All files</a> / <a href="index.html">bin</a> browserInstance.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/286</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/213</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/153</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/1</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">var e,t;<span class="cstat-no" title="statement not covered" >!<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e[e.InitConnection=1]="InitConnection",e[e.Authenticate=15]="Authenticate",e[e.Acknowledge=6]="Acknowledge",e[e.Reconnect=22]="Reconnect",e[e.Topic=26]="Topic",e[e.Identifier=11]="Identifier",e[e.Error=21]="Error",e[e.Alert=7]="Alert",e[e.AddAction=12]="AddAction",e[e.DeleteAction=16]="DeleteAction",e[e.Server=24]="Server",e[e.Payload=29]="Payload",e[e.Presence=14]="Presence"}</span>(e||(e={})),<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e[e.ArraySeparator=31]="ArraySeparator"}</span>(t||(t={}));c</span>onst n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{const t=<span class="cstat-no" title="statement not covered" >new ArrayBuffer(e.length),</span>n=<span class="cstat-no" title="statement not covered" >new Uint8Array(t),</span>s=<span class="cstat-no" title="statement not covered" >e.length+1;<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;s;t++)<span class="cstat-no" title="statement not covered" >n[t]=e.charCodeAt(t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>,</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >n(e),</span></span>i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >a(e),</span></span>a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >new Uint8Array(e).reduce((<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >e+String.fromCharCode(t))</span>,"");</span></span>class o{commandArray=<span class="cstat-no" title="statement not covered" >[];<span class="fstat-no" title="function not covered" ></span>se</span>tCommand(e,t){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return this;<span class="cstat-no" title="statement not covered" >t</span></span>his.commandArray.push(e);l</span>et n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return t?(Array.isArray(t)?n=this.convertArray(t):"string"==typeof t&amp;&amp;(n=this.convertStringNumberArray(t)),this.commandArray=[...this.commandArray,...n],this):this}<span class="fstat-no" title="function not covered" ></span>co</span>nvertStringNumberArray(e){const t=<span class="cstat-no" title="statement not covered" >s(e);<span class="cstat-no" title="statement not covered" ></span>return Array.from(new Uint8Array(t))}<span class="fstat-no" title="function not covered" ></span>co</span>nvertArray(e){<span class="cstat-no" title="statement not covered" >return e.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >this.convertStringNumberArray(e))</span>).map((<span class="fstat-no" title="function not covered" >e=</span>&gt;(<span class="cstat-no" title="statement not covered" >e.push(t.ArraySeparator),e)</span>)).flat()}<span class="fstat-no" title="function not covered" ></span>bu</span>ild(){<span class="cstat-no" title="statement not covered" >return new Uint8Array(this.commandArray)}</span>}const r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >new o;</span></span>class c{<span class="fstat-no" title="function not covered" >st</span>atic encode(t,n){const s=<span class="cstat-no" title="statement not covered" >new Uint8Array(1);<span class="cstat-no" title="statement not covered" ></span>s[0]=e.Payload;c</span>onst i=<span class="cstat-no" title="statement not covered" >t.build(),</span>a=<span class="cstat-no" title="statement not covered" >i.byteLength;</span>let o,r=<span class="cstat-no" title="statement not covered" >0,</span>c=<span class="cstat-no" title="statement not covered" >new Uint8Array(0);<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;(r=n.byteLength+1,c=new Uint8Array(n),o=a+1);c</span>onst h=<span class="cstat-no" title="statement not covered" >new ArrayBuffer(a+r);</span>let d=<span class="cstat-no" title="statement not covered" >new Uint8Array(h);<span class="cstat-no" title="statement not covered" ></span>return d.set(i,0),n&amp;&amp;(d.set(s,a),d.set(c,o)),d.buffer}<span class="fstat-no" title="function not covered" ></span>st</span>atic decode(t){const n=<span class="cstat-no" title="statement not covered" >t.byteLength,</span>s=<span class="cstat-no" title="statement not covered" >new Uint8Array(t);</span>let i=<span class="cstat-no" title="statement not covered" >s.indexOf(e.Payload);<span class="cstat-no" title="statement not covered" ></span>i=i&lt;0?n:i;c</span>onst a=<span class="cstat-no" title="statement not covered" >s.slice(0,i),</span>o=<span class="cstat-no" title="statement not covered" >i+1,</span>r=<span class="cstat-no" title="statement not covered" >this.extractCommands(a);<span class="cstat-no" title="statement not covered" ></span>return{commands:r,payload:t.slice(o,n),getCommand:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >!!r[e]&amp;&amp;r[e]}</span>}<span class="fstat-no" title="function not covered" ></span>st</span>atic hasSeparatorIndexes(e){<span class="cstat-no" title="statement not covered" >return e.indexOf(t.ArraySeparator)&gt;0}<span class="fstat-no" title="function not covered" ></span>st</span>atic commandActionUint8ArrayToString(e){<span class="cstat-no" title="statement not covered" >return e.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >String.fromCharCode(e))</span>).join("")}<span class="fstat-no" title="function not covered" ></span>st</span>atic commandActionUint8ArrayToStringArray(e){const n=<span class="cstat-no" title="statement not covered" >[];</span>let s=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return e.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >e===t.ArraySeparator?(n.push(s),s=[]):s.push(e)}</span>)),s.length&gt;0&amp;&amp;n.push(s),n.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >this.commandActionUint8ArrayToString(e.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >Number(e))</span>)))</span>)}<span class="fstat-no" title="function not covered" ></span>st</span>atic extractCommands(t){const n=<span class="cstat-no" title="statement not covered" >{};</span>let s=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>return t.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(Object.values(e).indexOf(t)&gt;=0)<span class="cstat-no" title="statement not covered" >return s=t,void(n[s]=[]);<span class="cstat-no" title="statement not covered" >n</span></span>[s].push(t)}</span>)),Object.keys(n).forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const t=<span class="cstat-no" title="statement not covered" >n[e];<span class="cstat-no" title="statement not covered" ></span>this.hasSeparatorIndexes(t)?n[e]=this.commandActionUint8ArrayToStringArray(t):0===t.length?n[e]=!0:n[e]=this.commandActionUint8ArrayToString(t)}</span>)),n}</span>}class h{connection;topicName;onReceiveCallback;identifiers=<span class="cstat-no" title="statement not covered" >[];</span>presence;<span class="fstat-no" title="function not covered" >co</span>nstructor(e,t,n){<span class="cstat-no" title="statement not covered" >this.setConnection(e),this.topicName=t,this.saveIdentifiers(n?.OR??[]),this.subscribe()}<span class="fstat-no" title="function not covered" ></span>fi</span>ndSavedIdentifier(e){const t=<span class="cstat-no" title="statement not covered" >Object.keys(e)[0]??"",</span>n=<span class="cstat-no" title="statement not covered" >Object.values(e)[0]??"";<span class="cstat-no" title="statement not covered" ></span>return this.identifiers.find((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(e){const s=<span class="cstat-no" title="statement not covered" >Object.keys(e)[0]??"",</span>i=<span class="cstat-no" title="statement not covered" >Object.values(e)[0]??"";<span class="cstat-no" title="statement not covered" ></span>return t===s&amp;&amp;n===i}</span>}</span>))}<span class="fstat-no" title="function not covered" ></span>sa</span>veIdentifiers(e){<span class="cstat-no" title="statement not covered" >Array.isArray(e)&amp;&amp;e.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.identifiers.find((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t===e)</span>)||this.identifiers.push(e)}</span>))}<span class="fstat-no" title="function not covered" ></span>de</span>leteSavedIdentifiers(e){const t=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>e.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.identifiers.find((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t===e)</span>)&amp;&amp;t.push(e)}</span>)),this.identifiers=t}<span class="fstat-no" title="function not covered" ></span>su</span>bscribe(){<span class="cstat-no" title="statement not covered" >if(!this.topicName&amp;&amp;0===this.identifiers?.length||!Array.isArray(this.identifiers))<span class="cstat-no" title="statement not covered" >return this;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >r().setCommand(e.Topic,this.topicName);<span class="cstat-no" title="statement not covered" ></span>this.identifiers.length&gt;0&amp;&amp;t.setCommand(e.Identifier,this.identifiers),this.presence&amp;&amp;t.setCommand(e.Presence,this.presence),t.setCommand(e.AddAction);c</span>onst n=<span class="cstat-no" title="statement not covered" >c.encode(t);<span class="cstat-no" title="statement not covered" ></span>this.send(n)}<span class="fstat-no" title="function not covered" ></span>se</span>tPresence(e){<span class="cstat-no" title="statement not covered" >return this.presence=e,this.subscribe(),this}<span class="fstat-no" title="function not covered" ></span>se</span>tConnection(e){<span class="cstat-no" title="statement not covered" >return this.connection=e,this}<span class="fstat-no" title="function not covered" ></span>_o</span>nReceiveMessage(e){<span class="cstat-no" title="statement not covered" >return this.onReceiveCallback&amp;&amp;this.onReceiveCallback(e),this}<span class="fstat-no" title="function not covered" ></span>on</span>Receive(e){<span class="cstat-no" title="statement not covered" >return this.onReceiveCallback=e,this}<span class="fstat-no" title="function not covered" ></span>ad</span>dIdentifiers(t){<span class="cstat-no" title="statement not covered" >if(!t?.OR?.length||0===t?.OR?.length)<span class="cstat-no" title="statement not covered" >return this;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >t?.OR??[];<span class="cstat-no" title="statement not covered" ></span>this.saveIdentifiers(n);c</span>onst s=<span class="cstat-no" title="statement not covered" >r().setCommand(e.Topic,this.topicName);<span class="cstat-no" title="statement not covered" ></span>n.length&gt;0&amp;&amp;s.setCommand(e.Identifier,n),s.setCommand(e.AddAction);c</span>onst i=<span class="cstat-no" title="statement not covered" >c.encode(s);<span class="cstat-no" title="statement not covered" ></span>return this.send(i),this}<span class="fstat-no" title="function not covered" ></span>re</span>moveIdentifiers(t){<span class="cstat-no" title="statement not covered" >if(0===t.length)<span class="cstat-no" title="statement not covered" >return this;<span class="cstat-no" title="statement not covered" >t</span></span>his.deleteSavedIdentifiers(t??[]);c</span>onst n=<span class="cstat-no" title="statement not covered" >r().setCommand(e.Topic,this.topicName);<span class="cstat-no" title="statement not covered" ></span>n.setCommand(e.Identifier,t),n.setCommand(e.DeleteAction);c</span>onst s=<span class="cstat-no" title="statement not covered" >c.encode(n);<span class="cstat-no" title="statement not covered" ></span>return this.send(s),this}<span class="fstat-no" title="function not covered" ></span>un</span>subscribe(){const t=<span class="cstat-no" title="statement not covered" >r().setCommand(e.Topic,this.topicName).setCommand(e.DeleteAction),</span>n=<span class="cstat-no" title="statement not covered" >c.encode(t);<span class="cstat-no" title="statement not covered" ></span>return this.send(n),!0}<span class="fstat-no" title="function not covered" ></span>pu</span>blish(t,n){<span class="cstat-no" title="statement not covered" >if(0===t.byteLength)<span class="cstat-no" title="statement not covered" >return this;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >r().setCommand(e.Topic,this.topicName);<span class="cstat-no" title="statement not covered" ></span>n?.length&gt;0&amp;&amp;s.setCommand(e.Identifier,n);c</span>onst i=<span class="cstat-no" title="statement not covered" >c.encode(s,t);<span class="cstat-no" title="statement not covered" ></span>return this.send(i),this}<span class="fstat-no" title="function not covered" ></span>se</span>nd(e){<span class="cstat-no" title="statement not covered" >this.connection&amp;&amp;this.connection.send(e)}</span>}var d,l,u,m,p,b,f,C;<span class="cstat-no" title="statement not covered" >!<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.Idle="idle",e.Connecting="connecting",e.Connected="connected",e.Disconnected="disconnected"}</span>(d||(d={})),<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.Nodejs="nodejs",e.Browser="browser"}</span>(l||(l={})),<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.Arraybuffer="arraybuffer"}</span>(u||(u={})),<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.Hidden="hidden",e.Visible="visible"}</span>(m||(m={})),<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.Subscribe="subscribe",e.Publish="publish",e.PubSub="pubSub"}</span>(p||(p={})),<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.Active="active",e.Inactive="inactive"}</span>(b||(b={})),<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.Standard="standard",e.Api="api"}</span>(f||(f={})),<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.RoundRobbin="roundRobin"}</span>(C||(C={}));c</span>onst y=<span class="cstat-no" title="statement not covered" >{DefaultWsHost:"tunnel.nolag.app",DefaultApiHost:"api.nolag.app",DefaultWsUrl:"/ws",DefaultPort:443,DefaultWsProtocol:"wss",DefaultApiUrl:"/v1",DefaultHttpProtocol:"https"};</span>class v{host;authToken;wsInstance;protocol;url;deviceConnectionId=<span class="cstat-no" title="statement not covered" >void 0;</span>environment;deviceTokenId=<span class="cstat-no" title="statement not covered" >null;</span>defaultCheckConnectionInterval=<span class="cstat-no" title="statement not covered" >100;</span>defaultCheckConnectionTimeout=<span class="cstat-no" title="statement not covered" >1e4;</span>checkConnectionInterval;checkConnectionTimeout;reConnect=<span class="cstat-no" title="statement not covered" >!1;</span>callbackOnOpen=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{};</span>callbackOnReceive=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{};</span>callbackOnClose=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{};</span>callbackOnError=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{};</span>connectionStatus=<span class="cstat-no" title="statement not covered" >d.Idle;</span>buffer=<span class="cstat-no" title="statement not covered" >[];</span>backpressureSendInterval=<span class="cstat-no" title="statement not covered" >0;</span>senderInterval=<span class="cstat-no" title="statement not covered" >0;</span>unifiedWebsocket;<span class="fstat-no" title="function not covered" >co</span>nstructor(e,t,n){<span class="cstat-no" title="statement not covered" >this.authToken=t??"",this.host=n?.host??y.DefaultWsHost,this.protocol=n?.protocol??y.DefaultWsProtocol,this.url=y.DefaultWsUrl,this.checkConnectionInterval=n?.checkConnectionInterval??this.defaultCheckConnectionInterval,this.checkConnectionTimeout=n?.checkConnectionTimeout??this.defaultCheckConnectionTimeout,this.unifiedWebsocket=e,this.startSender()}<span class="fstat-no" title="function not covered" ></span>st</span>artSender(){<span class="cstat-no" title="statement not covered" >this.senderInterval=setInterval((<span class="fstat-no" title="function not covered" >()</span>=&gt;{const e=<span class="cstat-no" title="statement not covered" >this.buffer.shift();<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;this.wsInstance&amp;&amp;this.wsInstance.send&amp;&amp;this.wsInstance.send(e)}</span>),this.backpressureSendInterval)}<span class="fstat-no" title="function not covered" ></span>sl</span>owDownSender(e){<span class="cstat-no" title="statement not covered" >clearInterval(this.senderInterval),this.backpressureSendInterval=e,this.startSender()}<span class="fstat-no" title="function not covered" ></span>ad</span>dToBuffer(e){<span class="cstat-no" title="statement not covered" >this.buffer.push(e)}<span class="fstat-no" title="function not covered" ></span>se</span>tReConnect(e){<span class="cstat-no" title="statement not covered" >e&amp;&amp;(this.reConnect=e)}<span class="fstat-no" title="function not covered" ></span>co</span>nnect(){<span class="cstat-no" title="statement not covered" >return this.connectionStatus=d.Idle,this.initWebsocketConnection(),new Promise((<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{const n=<span class="cstat-no" title="statement not covered" >setInterval((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.connectionStatus===d.Connected&amp;&amp;(e(this),clearInterval(n))}</span>),this.checkConnectionInterval);<span class="cstat-no" title="statement not covered" ></span>setTimeout((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.connectionStatus===d.Idle&amp;&amp;(t(!0),clearInterval(n))}</span>),this.checkConnectionTimeout)}</span>))}<span class="fstat-no" title="function not covered" ></span>di</span>sconnect(){<span class="cstat-no" title="statement not covered" >this.wsInstance&amp;&amp;this.wsInstance.close&amp;&amp;(this.wsInstance.close(),this.wsInstance=void 0)}<span class="fstat-no" title="function not covered" ></span>in</span>itWebsocketConnection(){<span class="cstat-no" title="statement not covered" >this.connectionStatus!==d.Connected&amp;&amp;(this.wsInstance=this.unifiedWebsocket(`${this.protocol}://${this.host}${this.url}`),this.wsInstance&amp;&amp;(this.wsInstance.onOpen=<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >this._onOpen(e)}</span>,this.wsInstance.onMessage=<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >this._onReceive(e)}</span>,this.wsInstance.onClose=<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >this._onClose(e)}</span>,this.wsInstance.onError=<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >this._onError(e)}</span>))}<span class="fstat-no" title="function not covered" ></span>au</span>thenticate(){<span class="cstat-no" title="statement not covered" >this.connectionStatus=d.Connecting;c</span>onst{authToken:t}=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >r().setCommand(e.Authenticate,t);<span class="cstat-no" title="statement not covered" ></span>this.reConnect&amp;&amp;n.setCommand(e.Reconnect),this.send(c.encode(n))}<span class="fstat-no" title="function not covered" ></span>on</span>Open(e){<span class="cstat-no" title="statement not covered" >this.callbackOnOpen=e}<span class="fstat-no" title="function not covered" ></span>on</span>ReceiveMessage(e){<span class="cstat-no" title="statement not covered" >this.callbackOnReceive=e}<span class="fstat-no" title="function not covered" ></span>on</span>Close(e){<span class="cstat-no" title="statement not covered" >this.callbackOnClose=e}<span class="fstat-no" title="function not covered" ></span>on</span>Error(e){<span class="cstat-no" title="statement not covered" >this.callbackOnError=e}<span class="fstat-no" title="function not covered" ></span>_o</span>nOpen(e){<span class="cstat-no" title="statement not covered" >this.connectionStatus,d.Idle,this.callbackOnOpen(void 0,e)}<span class="fstat-no" title="function not covered" ></span>_o</span>nReceive(t){const n=<span class="cstat-no" title="statement not covered" >t??new ArrayBuffer(0),</span>s=<span class="cstat-no" title="statement not covered" >c.decode(n);<span class="cstat-no" title="statement not covered" ></span>if(0!==n.byteLength){<span class="cstat-no" title="statement not covered" >if(!s.getCommand(e.InitConnection)||this.connectionStatus!==d.Idle)<span class="cstat-no" title="statement not covered" >return s.getCommand(e.Acknowledge)&amp;&amp;this.connectionStatus===d.Connecting?(this.connectionStatus=d.Connected,void(this.deviceTokenId=s.getCommand(e.Acknowledge))):s.getCommand(e.Error)?(this.connectionStatus=d.Disconnected,void this.callbackOnError(s.getCommand(e.Alert),void 0)):void this.callbackOnReceive(void 0,{topicName:s.getCommand(e.Topic),presences:s.getCommand(e.Presence),identifiers:s.getCommand(e.Identifier),data:s.payload});<span class="cstat-no" title="statement not covered" >t</span></span>his.authenticate()}</span>}<span class="fstat-no" title="function not covered" ></span>_o</span>nClose(e){<span class="cstat-no" title="statement not covered" >this.connectionStatus=d.Disconnected,this.callbackOnClose(e,void 0)}<span class="fstat-no" title="function not covered" ></span>_o</span>nError(e){<span class="cstat-no" title="statement not covered" >this.connectionStatus=d.Disconnected,this.callbackOnError(e,void 0)}<span class="fstat-no" title="function not covered" ></span>se</span>nd(e){<span class="cstat-no" title="statement not covered" >this.addToBuffer(e)}<span class="fstat-no" title="function not covered" ></span>he</span>artbeat(){<span class="cstat-no" title="statement not covered" >this.wsInstance&amp;&amp;this.send(new ArrayBuffer(0))}</span>}class g{noLagClient;connectOptions;authToken;topics=<span class="cstat-no" title="statement not covered" >{};</span>heartbeatTimer;defaultCheckConnectionInterval=<span class="cstat-no" title="statement not covered" >1e4;</span>checkConnectionInterval;heartBeatInterval=<span class="cstat-no" title="statement not covered" >2e4;</span>visibilityState=<span class="cstat-no" title="statement not covered" >m.Visible;</span>callbackOnReceive;callbackOnDisconnect=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{};</span>callbackOnReconnect=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{};</span>callbackOnReceivedError=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{};<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(e,t,n,s){<span class="cstat-no" title="statement not covered" >this.checkConnectionInterval=s?.checkConnectionInterval??this.defaultCheckConnectionInterval,this.connectOptions=s??void 0,this.authToken=t,this.noLagClient=new v(e,this.authToken,this.connectOptions),this.onClose(),this.onError(),this.onReceiveMessage(),n?.disconnectOnNoVisibility&amp;&amp;this.onVisibilityChange()}<span class="fstat-no" title="function not covered" ></span>ge</span>t deviceTokenId(){<span class="cstat-no" title="statement not covered" >return this.noLagClient?.deviceTokenId}<span class="fstat-no" title="function not covered" ></span>st</span>artHeartbeat(){<span class="cstat-no" title="statement not covered" >this.heartbeatTimer=setInterval((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.noLagClient&amp;&amp;this.noLagClient.heartbeat()}</span>),this.heartBeatInterval)}<span class="fstat-no" title="function not covered" ></span>st</span>opHeartbeat(){<span class="cstat-no" title="statement not covered" >clearInterval(this.heartbeatTimer)}<span class="fstat-no" title="function not covered" ></span>as</span>ync initiate(e){<span class="cstat-no" title="statement not covered" >return this.noLagClient&amp;&amp;(this.noLagClient.setReConnect(e),await this.noLagClient.connect(),this.startHeartbeat()),this}<span class="fstat-no" title="function not covered" ></span>on</span>VisibilityChange(){<span class="cstat-no" title="statement not covered" >document.addEventListener&amp;&amp;document.addEventListener("visibilitychange",(<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{<span class="cstat-no" title="statement not covered" >switch(this.visibilityState=document.visibilityState,this.visibilityState){case m.Hidden:<span class="cstat-no" title="statement not covered" >this.noLagClient?.disconnect(),this.stopHeartbeat();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase m.Visible:<span class="cstat-no" title="statement not covered" >await this.initiate(!0)}</span>}</span>))}<span class="fstat-no" title="function not covered" ></span>on</span>ReceiveMessage(){<span class="cstat-no" title="statement not covered" >this.noLagClient&amp;&amp;this.noLagClient?.onReceiveMessage((<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{const{topicName:n,identifiers:s}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>this.noLagClient&amp;&amp;!this.topics[n]&amp;&amp;(this.topics[n]=new h(this.noLagClient,n,{OR:s})),n&amp;&amp;this.topics[n]&amp;&amp;this.topics[n]?._onReceiveMessage(t),"function"==typeof this.callbackOnReceive&amp;&amp;this.callbackOnReceive(t)}</span>))}<span class="fstat-no" title="function not covered" ></span>re</span>connect(){<span class="cstat-no" title="statement not covered" >this.stopHeartbeat(),setTimeout((<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{<span class="cstat-no" title="statement not covered" >await this.initiate(!0),"function"==typeof this.callbackOnReconnect&amp;&amp;this.callbackOnReconnect()}</span>),this.checkConnectionInterval)}<span class="fstat-no" title="function not covered" ></span>ca</span>nReconnect(){<span class="cstat-no" title="statement not covered" >return this.visibilityState!==m.Hidden}<span class="fstat-no" title="function not covered" ></span>do</span>Reconnect(){<span class="cstat-no" title="statement not covered" >this.canReconnect()?this.reconnect():(this.stopHeartbeat(),"function"==typeof this.callbackOnDisconnect&amp;&amp;this.callbackOnDisconnect("connection retry timeout."))}<span class="fstat-no" title="function not covered" ></span>on</span>Close(){<span class="cstat-no" title="statement not covered" >this.noLagClient&amp;&amp;this.noLagClient.onClose((<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >this.doReconnect(),"function"==typeof this.callbackOnReceivedError&amp;&amp;this.callbackOnReceivedError(e)}</span>))}<span class="fstat-no" title="function not covered" ></span>on</span>Error(){<span class="cstat-no" title="statement not covered" >this.noLagClient&amp;&amp;this.noLagClient.onError((<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >"function"==typeof this.callbackOnReceivedError&amp;&amp;this.callbackOnReceivedError(e)}</span>))}<span class="fstat-no" title="function not covered" ></span>on</span>Receive(e){<span class="cstat-no" title="statement not covered" >this.callbackOnReceive=e}<span class="fstat-no" title="function not covered" ></span>di</span>sconnect(){<span class="cstat-no" title="statement not covered" >this.visibilityState=m.Hidden,this.noLagClient?.disconnect()}<span class="fstat-no" title="function not covered" ></span>on</span>Disconnect(e){<span class="cstat-no" title="statement not covered" >this.callbackOnDisconnect=e}<span class="fstat-no" title="function not covered" ></span>on</span>Reconnect(e){<span class="cstat-no" title="statement not covered" >this.callbackOnReconnect=e}<span class="fstat-no" title="function not covered" ></span>on</span>Errors(e){<span class="cstat-no" title="statement not covered" >this.callbackOnReceivedError=e}<span class="fstat-no" title="function not covered" ></span>ge</span>tTopic(e){<span class="cstat-no" title="statement not covered" >return!this.topics[e]&amp;&amp;this.noLagClient&amp;&amp;(this.topics[e]=new h(this.noLagClient,e,{})),this.topics[e]}<span class="fstat-no" title="function not covered" ></span>un</span>subscribe(e){<span class="cstat-no" title="statement not covered" >return!!this.topics[e]&amp;&amp;(this.topics[e]?.unsubscribe(),delete this.topics[e],!0)}<span class="fstat-no" title="function not covered" ></span>su</span>bscribe(e,t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >if(this.noLagClient)<span class="cstat-no" title="statement not covered" >return this.topics[e]||(this.topics[e]=new h(this.noLagClient,e,t)),this.topics[e]}<span class="fstat-no" title="function not covered" ></span></span>pu</span>blish(t,n,s=<span class="branch-0 cbranch-no" title="branch not covered" >[])</span>{<span class="cstat-no" title="statement not covered" >if(this.noLagClient&amp;&amp;this.noLagClient.send){<span class="cstat-no" title="statement not covered" >this.stopHeartbeat();c</span>onst i=<span class="cstat-no" title="statement not covered" >r().setCommand(e.Topic,t);<span class="cstat-no" title="statement not covered" ></span>s?.length&gt;0&amp;&amp;i.setCommand(e.Identifier,s);c</span>onst a=<span class="cstat-no" title="statement not covered" >c.encode(i,n);<span class="cstat-no" title="statement not covered" ></span>this.noLagClient.send(a),this.startHeartbeat()}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>t status(){<span class="cstat-no" title="statement not covered" >return this.noLagClient?.connectionStatus??null}</span>}const I=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{const t=<span class="cstat-no" title="statement not covered" >new WebSocket(e);<span class="cstat-no" title="statement not covered" ></span>t.binaryType=u.Arraybuffer;c</span>onst n=<span class="cstat-no" title="statement not covered" >{send:<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >t.send(e)}</span>,close:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.close()}</span>};<span class="cstat-no" title="statement not covered" ></span>return t.onopen=<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >n?.onOpen&amp;&amp;n.onOpen(e)}</span>,t.onclose=<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >n?.onClose&amp;&amp;n.onClose(e)}</span>,t.onerror=<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >n?.onError&amp;&amp;n.onError(e)}</span>,t.onmessage=<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >n?.onMessage&amp;&amp;n.onMessage(e.data)}</span>,n}</span>,</span>A=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return"";c</span></span>onst t=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>Object.keys(n).map((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >t.push(`${e}=${n[e]}`)}</span>));c</span>onst s=<span class="cstat-no" title="statement not covered" >t.join("&amp;");<span class="cstat-no" title="statement not covered" ></span>return s?`?${s}`:""}</span>;</span>class k{routeNamespace=<span class="cstat-no" title="statement not covered" >"devices";</span>parentRouteNamespace;tunnelId;requestParams;<span class="fstat-no" title="function not covered" >co</span>nstructor(e,t,n){<span class="cstat-no" title="statement not covered" >this.parentRouteNamespace=e,this.tunnelId=t,this.requestParams=n}<span class="fstat-no" title="function not covered" ></span>as</span>ync createDevice(e){<span class="cstat-no" title="statement not covered" >return(await fetch(`${this.requestParams.baseURL}/${this.parentRouteNamespace}/${this.tunnelId}/${this.routeNamespace}`,{method:"POST",headers:this.requestParams.headers,body:JSON.stringify(e)})).json()}<span class="fstat-no" title="function not covered" ></span>as</span>ync getDeviceById(e){<span class="cstat-no" title="statement not covered" >return(await fetch(`${this.requestParams.baseURL}/${this.parentRouteNamespace}/${this.tunnelId}/${this.routeNamespace}/${e}`,{method:"GET",headers:this.requestParams.headers})).json()}<span class="fstat-no" title="function not covered" ></span>as</span>ync listDevices(e){const t=<span class="cstat-no" title="statement not covered" >A(e);<span class="cstat-no" title="statement not covered" ></span>return(await fetch(`${this.requestParams.baseURL}/${this.parentRouteNamespace}/${this.tunnelId}/${this.routeNamespace}${t}`,{method:"GET",headers:this.requestParams.headers})).json()}<span class="fstat-no" title="function not covered" ></span>as</span>ync updateDevice(e,t){<span class="cstat-no" title="statement not covered" >return(await fetch(`${this.requestParams.baseURL}/${this.parentRouteNamespace}/${this.tunnelId}/${this.routeNamespace}/${e}`,{method:"PATCH",headers:this.requestParams.headers,body:JSON.stringify(t)})).json()}<span class="fstat-no" title="function not covered" ></span>as</span>ync deleteDevice(e){<span class="cstat-no" title="statement not covered" >return(await fetch(`${this.requestParams.baseURL}/${this.parentRouteNamespace}/${this.tunnelId}/${this.routeNamespace}/${e}`,{method:"DELETE",headers:this.requestParams.headers})).json()}</span>}const R=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >as</span>ync(t,n,s,i,a,o,h)=&gt;{const d=<span class="cstat-no" title="statement not covered" >r().setCommand(e.Topic,n).setCommand(e.Identifier,s).setCommand(e.AddAction),</span>l=<span class="cstat-no" title="statement not covered" >c.encode(d,t),</span>u=<span class="cstat-no" title="statement not covered" >`${h?.protocol}://${h?.wsHost}`;<span class="cstat-no" title="statement not covered" ></span>return await fetch(`${u}/${a}/${i}/publish`,{headers:o.headers,method:"POST",body:l}),!0}</span>;</span>class O{routeNamespace=<span class="cstat-no" title="statement not covered" >"topics";</span>parentRouteNamespace;tunnelId;requestParams;<span class="fstat-no" title="function not covered" >co</span>nstructor(e,t,n){<span class="cstat-no" title="statement not covered" >this.parentRouteNamespace=e,this.tunnelId=t,this.requestParams=n}<span class="fstat-no" title="function not covered" ></span>as</span>ync createTopic(e){<span class="cstat-no" title="statement not covered" >return(await fetch(`${this.requestParams.baseURL}/${this.parentRouteNamespace}/${this.tunnelId}/${this.routeNamespace}`,{method:"POST",headers:this.requestParams.headers,body:JSON.stringify(e)})).json()}<span class="fstat-no" title="function not covered" ></span>as</span>ync getTopicById(e){<span class="cstat-no" title="statement not covered" >return(await fetch(`${this.requestParams.baseURL}/${this.parentRouteNamespace}/${this.tunnelId}/${this.routeNamespace}/${e}`,{method:"GET",headers:this.requestParams.headers})).json()}<span class="fstat-no" title="function not covered" ></span>as</span>ync listTopics(e){const t=<span class="cstat-no" title="statement not covered" >e?A(e):"";<span class="cstat-no" title="statement not covered" ></span>return(await fetch(`${this.requestParams.baseURL}/${this.parentRouteNamespace}/${this.tunnelId}/${this.routeNamespace}${t}`,{method:"GET",headers:this.requestParams.headers})).json()}<span class="fstat-no" title="function not covered" ></span>as</span>ync updateTopic(e,t){<span class="cstat-no" title="statement not covered" >return(await fetch(`${this.requestParams.baseURL}/${this.parentRouteNamespace}/${this.tunnelId}/${this.routeNamespace}/${e}`,{method:"PATCH",headers:this.requestParams.headers,body:JSON.stringify(t)})).json()}<span class="fstat-no" title="function not covered" ></span>as</span>ync deleteTopic(e){<span class="cstat-no" title="statement not covered" >return(await fetch(`${this.requestParams.baseURL}/${this.parentRouteNamespace}/${this.tunnelId}/${this.routeNamespace}/${e}`,{method:"DELETE",headers:this.requestParams.headers})).json()}</span>}class w{routeNamespace=<span class="cstat-no" title="statement not covered" >"tunnels";</span>tunnelId;requestParams;apiTunnel;<span class="fstat-no" title="function not covered" >co</span>nstructor(e,t,n){<span class="cstat-no" title="statement not covered" >this.tunnelId=t,this.requestParams=n,this.apiTunnel=e}<span class="fstat-no" title="function not covered" ></span>ge</span>t topics(){<span class="cstat-no" title="statement not covered" >return new O(this.routeNamespace,this.tunnelId,this.requestParams)}<span class="fstat-no" title="function not covered" ></span>ge</span>t devices(){<span class="cstat-no" title="statement not covered" >return new k(this.routeNamespace,this.tunnelId,this.requestParams)}<span class="fstat-no" title="function not covered" ></span>as</span>ync getTunnel(){<span class="cstat-no" title="statement not covered" >return(await fetch(`${this.requestParams.baseURL}/${this.routeNamespace}/${this.tunnelId}`,{method:"GET",headers:this.requestParams.headers})).json()}<span class="fstat-no" title="function not covered" ></span>as</span>ync updateTunnel(e){<span class="cstat-no" title="statement not covered" >return fetch(`${this.requestParams.baseURL}/tunnels`,{method:"PATCH",headers:this.requestParams.headers,body:JSON.stringify(e)}).then((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.json())</span>)}<span class="fstat-no" title="function not covered" ></span>as</span>ync deleteTunnel(){<span class="cstat-no" title="statement not covered" >return(await fetch(`${this.requestParams.baseURL}/${this.routeNamespace}/${this.tunnelId}`,{method:"DELETE",headers:this.requestParams.headers})).json()}<span class="fstat-no" title="function not covered" ></span>as</span>ync publish(e){const{data:t,topicName:n,identifiers:s}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return R(t,n,s,this.tunnelId,this.routeNamespace,this.requestParams,this.apiTunnel.connectOptions)}</span>}class ${apiKey;connectOptions;requestParams;<span class="fstat-no" title="function not covered" >co</span>nstructor(e,t){<span class="cstat-no" title="statement not covered" >this.connectOptions={host:y.DefaultApiHost,protocol:y.DefaultHttpProtocol,url:y.DefaultApiUrl,wsUrl:y.DefaultWsUrl,wsHost:y.DefaultWsHost,apiKey:e,...t},this.apiKey=e,this.requestParams={baseURL:`${this.connectOptions?.protocol}://${this.connectOptions?.host}${this.connectOptions?.url}`,headers:{"X-API-Key":this.apiKey,"Content-Type":"application/json"}}}<span class="fstat-no" title="function not covered" ></span>as</span>ync tunnels(e){const t=<span class="cstat-no" title="statement not covered" >new URLSearchParams(e).toString();<span class="cstat-no" title="statement not covered" ></span>return(await fetch(`${this.requestParams.baseURL}/tunnels${t?`?${t}`:""}`,{headers:this.requestParams.headers,method:"get"})).json()}<span class="fstat-no" title="function not covered" ></span>as</span>ync createTunnel(e){<span class="cstat-no" title="statement not covered" >return fetch(`${this.requestParams.baseURL}/tunnels`,{method:"POST",headers:this.requestParams.headers,body:JSON.stringify(e)}).then((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.json())</span>)}<span class="fstat-no" title="function not covered" ></span>tu</span>nnel(e){<span class="cstat-no" title="statement not covered" >return new w(this,e,this.requestParams)}</span>}const P=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >new $(e,t);<span class="cstat-no" title="statement not covered" ></span></span>console.log("load browserInstance");c</span>onst T=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >as</span>ync(e,t,n)=&gt;<span class="cstat-no" title="statement not covered" >new g(I,e,t,n).initiate();</span></span>export{P as Api,y as CONSTANT,p as EAccessPermission,d as EConnectionStatus,u as EEncoding,l as EEnvironment,C as ELoadBalanceType,b as EStatus,f as ETopicType,m as EVisibilityState,c as NqlTransport,h as Topic,g as Tunnel,w as TunnelApi,k as TunnelDevice,R as TunnelPublish,O as TunnelTopic,T as WebSocketClient,i as bufferToString,A as generateQueryString,n as stringToArrayBuffer,s as stringToBuffer,a as uint8ArrayToString};
//# sourceMappingURL=browserInstance.js.map
&nbsp;</pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2025-01-03T12:19:28.405Z
            </div>
        <script src="../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../sorter.js"></script>
        <script src="../block-navigation.js"></script>
    </body>
</html>
    